# **代理模式**
<ul>
    <li>
        <a href="https://zhuanlan.zhihu.com/p/32715893">知乎专栏-代理模式</a>
    </li>
    <li>
        <a href="https://blog.csdn.net/briblue/article/details/73928350">CSDN-代理模式</a>
    </li>
</ul>



- 代理模式是设计模式中一种常见的设计模式，我们往往通过代理模式可以拦截目标方法的执行，进行自己想要的业务需求，例如日志拦截，权限校验等工作。
- 代理模式的实现方式如下：
    - 在代理模式中，我们将类分为以下三类角色
    - 抽象对象Subject，代理对象Proxy，以及真实对象RealSubject。
    - 当我们想要执行某一个动作时，我们不是直接调用RealSubject的方法，而是通过Proxy间接调用RealSubject的方法。为了使Proxy和RealSubject对外界提供功能保持一致，我们定义了一个接口Subject，表示他们可以提供的业务的能力，Proxy和RealSubject均实现了这一个接口，不同的是RealSubject是真正的业务实现，而Proxy只是简单调用了字段subject对应的函数。

- 代理模式的好处
    - 代理模式通过引入代理对象这一角色，在一定程度上隔离了业务发起方和业务实际处理方，避免了两者之间的直接交互，在不更改业务执行流程的前提下，为灵活的需求变化提供了可拓展的编码空间。

## 静态代理

- 缺点
    - 代理者使用了业务接口，因此需要实现接口中声明的所有方法 ：当一个接口中定义了100个甚至更多的方法时，我们需要实现相应数量的方法。如果是好几个接口，那这个工作量可想而知；
    - 业务逻辑的关注点分散在类中的各个方法中 ，增加了类功能维护的成本：我们如果想实现一个功能，但方法开始执行时，输出对应的日志信息。如果通过现有实现方式，代理对象的每个方法中我们都要调用对应的日志函数，工作量很大；另外，如果那一天，我们希望改下部分方法的处理逻辑，工作量依旧存在。
    
## 动态代理

- jdk
- cglib

### 实现原理

- 类加载器
- JDK中的动态代理通过字节码生成 技术，产生目标代理对象 ，将用户对目标接口的方法调用统一路由到特定的接口 java.lang.reflect.InvocationHandler ，将客户端发起的调用转化成一一对应的Method对象，实现了代理动作的抽象 ，实现代理的目的。

### 面向切面编程

## 策略模式???


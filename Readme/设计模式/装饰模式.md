# 装饰模式

![装饰模式](https://upload-images.jianshu.io/upload_images/7236980-8bf9cbff2ee7f71b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/628)

![装饰模式](https://upload-images.jianshu.io/upload_images/7236980-dd3463cc3d5787c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

![装饰模式(Decorator)](https://upload-images.jianshu.io/upload_images/7236980-5355338425e88867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641)

## 透明性要求

- 装饰者模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。
- 然而纯碎的装饰者模式很难找到，装饰者模式的用意是在不改变接口的前提下，增强所考虑的类的性能，在增强性能的时候，往往需要建立新的公开的方法。这就导致了大多数的装饰者模式的实现都是“半透明”的，而不是完全透明的，换言之，允许装饰者模式改变接口，增加新的方法，这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法。
半透明的装饰者模式是介于装饰者模式和适配器模式之间的，适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数装饰者模式实际上是半透明的装饰者模式，这样的装饰者模式也称作半装饰、半适配器模式
装饰者模式和适配器模式都是包装模式（Wrapper Pattern），它们都是通过封装其他对象达到设计的目的，但是它们的形态有很大区别
- 理想的装饰者模式在对被装饰对象进行功能增强的同时，要求具体构件、装饰者的接口与抽象构件的接口完全一致，而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合
装饰者模式有透明和半透明两种，这两种的区别就在于装饰者的接口与抽象构件的接口是否完全一致。透明的装饰者模式也就是理想的装饰者模式，要求具体构件、装饰者的接口与抽象构件的接口完全一致。相反，如果装饰者的接口与抽象构件的接口不一致，也就是说装饰者的接口比抽象构件的接口宽的话，装饰者实际上已经成了一个适配器，这种装饰者模式也是可以接受的，称为“半透明”的装饰模式
